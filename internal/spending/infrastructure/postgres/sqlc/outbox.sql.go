// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertOutboxEntry = `-- name: InsertOutboxEntry :exec
INSERT INTO spending.outbox (
	event_id, event_type, tenant_id,
	correlation_id, causation_id,
	payload, occurred_at
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertOutboxEntryParams struct {
	EventID       string
	EventType     string
	TenantID      string
	CorrelationID pgtype.Text
	CausationID   pgtype.Text
	Payload       []byte
	OccurredAt    pgtype.Timestamptz
}

func (q *Queries) InsertOutboxEntry(ctx context.Context, arg InsertOutboxEntryParams) error {
	_, err := q.db.Exec(ctx, insertOutboxEntry,
		arg.EventID,
		arg.EventType,
		arg.TenantID,
		arg.CorrelationID,
		arg.CausationID,
		arg.Payload,
		arg.OccurredAt,
	)
	return err
}

const listUnpublishedOutbox = `-- name: ListUnpublishedOutbox :many
SELECT event_id, event_type, tenant_id,
	   COALESCE(correlation_id, '') AS correlation_id,
	   COALESCE(causation_id, '') AS causation_id,
	   payload, occurred_at, published_at
FROM spending.outbox
WHERE published_at IS NULL
ORDER BY occurred_at ASC
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type ListUnpublishedOutboxRow struct {
	EventID       string
	EventType     string
	TenantID      string
	CorrelationID string
	CausationID   string
	Payload       []byte
	OccurredAt    pgtype.Timestamptz
	PublishedAt   pgtype.Timestamptz
}

func (q *Queries) ListUnpublishedOutbox(ctx context.Context, limit int32) ([]ListUnpublishedOutboxRow, error) {
	rows, err := q.db.Query(ctx, listUnpublishedOutbox, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnpublishedOutboxRow
	for rows.Next() {
		var i ListUnpublishedOutboxRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.TenantID,
			&i.CorrelationID,
			&i.CausationID,
			&i.Payload,
			&i.OccurredAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOutboxPublished = `-- name: MarkOutboxPublished :exec
UPDATE spending.outbox
SET published_at = $1
WHERE event_id = ANY($2::varchar[])
`

type MarkOutboxPublishedParams struct {
	PublishedAt pgtype.Timestamptz
	EventIds    []string
}

func (q *Queries) MarkOutboxPublished(ctx context.Context, arg MarkOutboxPublishedParams) error {
	_, err := q.db.Exec(ctx, markOutboxPublished, arg.PublishedAt, arg.EventIds)
	return err
}

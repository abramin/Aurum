// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: authorization.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAuthorizationByID = `-- name: GetAuthorizationByID :one
SELECT id, tenant_id, card_account_id,
	   authorized_amount, authorized_currency,
	   captured_amount, captured_currency,
	   COALESCE(merchant_ref, '') AS merchant_ref,
	   COALESCE(reference, '') AS reference,
	   state, version, created_at, updated_at
FROM spending.authorizations
WHERE id = $1 AND tenant_id = $2
`

type GetAuthorizationByIDParams struct {
	ID       uuid.UUID
	TenantID string
}

type GetAuthorizationByIDRow struct {
	ID                 uuid.UUID
	TenantID           string
	CardAccountID      uuid.UUID
	AuthorizedAmount   pgtype.Numeric
	AuthorizedCurrency string
	CapturedAmount     pgtype.Numeric
	CapturedCurrency   string
	MerchantRef        string
	Reference          string
	State              string
	Version            int32
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
}

func (q *Queries) GetAuthorizationByID(ctx context.Context, arg GetAuthorizationByIDParams) (GetAuthorizationByIDRow, error) {
	row := q.db.QueryRow(ctx, getAuthorizationByID, arg.ID, arg.TenantID)
	var i GetAuthorizationByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CardAccountID,
		&i.AuthorizedAmount,
		&i.AuthorizedCurrency,
		&i.CapturedAmount,
		&i.CapturedCurrency,
		&i.MerchantRef,
		&i.Reference,
		&i.State,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAuthorization = `-- name: UpsertAuthorization :execrows
INSERT INTO spending.authorizations (
	id, tenant_id, card_account_id,
	authorized_amount, authorized_currency,
	captured_amount, captured_currency,
	merchant_ref, reference, state, version,
	created_at, updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
ON CONFLICT (id) DO UPDATE SET
	captured_amount = EXCLUDED.captured_amount,
	captured_currency = EXCLUDED.captured_currency,
	state = EXCLUDED.state,
	version = EXCLUDED.version,
	updated_at = EXCLUDED.updated_at
WHERE spending.authorizations.version = EXCLUDED.version - 1
`

type UpsertAuthorizationParams struct {
	ID                 uuid.UUID
	TenantID           string
	CardAccountID      uuid.UUID
	AuthorizedAmount   pgtype.Numeric
	AuthorizedCurrency string
	CapturedAmount     pgtype.Numeric
	CapturedCurrency   string
	MerchantRef        pgtype.Text
	Reference          pgtype.Text
	State              string
	Version            int32
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
}

func (q *Queries) UpsertAuthorization(ctx context.Context, arg UpsertAuthorizationParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertAuthorization,
		arg.ID,
		arg.TenantID,
		arg.CardAccountID,
		arg.AuthorizedAmount,
		arg.AuthorizedCurrency,
		arg.CapturedAmount,
		arg.CapturedCurrency,
		arg.MerchantRef,
		arg.Reference,
		arg.State,
		arg.Version,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

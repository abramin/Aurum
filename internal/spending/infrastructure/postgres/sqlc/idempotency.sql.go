// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: idempotency.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getIdempotencyEntry = `-- name: GetIdempotencyEntry :one
SELECT tenant_id, idempotency_key, resource_id, status_code, response_body, created_at
FROM spending.idempotency_keys
WHERE tenant_id = $1 AND idempotency_key = $2
`

type GetIdempotencyEntryParams struct {
	TenantID       string
	IdempotencyKey string
}

func (q *Queries) GetIdempotencyEntry(ctx context.Context, arg GetIdempotencyEntryParams) (SpendingIdempotencyKey, error) {
	row := q.db.QueryRow(ctx, getIdempotencyEntry, arg.TenantID, arg.IdempotencyKey)
	var i SpendingIdempotencyKey
	err := row.Scan(
		&i.TenantID,
		&i.IdempotencyKey,
		&i.ResourceID,
		&i.StatusCode,
		&i.ResponseBody,
		&i.CreatedAt,
	)
	return i, err
}

const insertIdempotencyIfAbsent = `-- name: InsertIdempotencyIfAbsent :one
WITH new_row AS (
	INSERT INTO spending.idempotency_keys (
		tenant_id, idempotency_key, resource_id, status_code, response_body, created_at
	) VALUES ($1, $2, $3, $4, $5, $6)
	ON CONFLICT (tenant_id, idempotency_key) DO NOTHING
	RETURNING tenant_id, idempotency_key, resource_id, status_code, response_body, created_at, true AS inserted
)
SELECT tenant_id, idempotency_key, resource_id, status_code, response_body, created_at, inserted
FROM new_row
UNION ALL
SELECT tenant_id, idempotency_key, resource_id, status_code, response_body, created_at, false AS inserted
FROM spending.idempotency_keys
WHERE tenant_id = $1 AND idempotency_key = $2
	AND NOT EXISTS (SELECT 1 FROM new_row)
`

type InsertIdempotencyIfAbsentParams struct {
	TenantID       string
	IdempotencyKey string
	ResourceID     string
	StatusCode     int32
	ResponseBody   []byte
	CreatedAt      pgtype.Timestamptz
}

type InsertIdempotencyIfAbsentRow struct {
	TenantID       string
	IdempotencyKey string
	ResourceID     string
	StatusCode     int32
	ResponseBody   []byte
	CreatedAt      pgtype.Timestamptz
	Inserted       bool
}

func (q *Queries) InsertIdempotencyIfAbsent(ctx context.Context, arg InsertIdempotencyIfAbsentParams) (InsertIdempotencyIfAbsentRow, error) {
	row := q.db.QueryRow(ctx, insertIdempotencyIfAbsent,
		arg.TenantID,
		arg.IdempotencyKey,
		arg.ResourceID,
		arg.StatusCode,
		arg.ResponseBody,
		arg.CreatedAt,
	)
	var i InsertIdempotencyIfAbsentRow
	err := row.Scan(
		&i.TenantID,
		&i.IdempotencyKey,
		&i.ResourceID,
		&i.StatusCode,
		&i.ResponseBody,
		&i.CreatedAt,
		&i.Inserted,
	)
	return i, err
}

const upsertIdempotencyEntry = `-- name: UpsertIdempotencyEntry :exec
INSERT INTO spending.idempotency_keys (
	tenant_id, idempotency_key, resource_id, status_code, response_body, created_at
) VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (tenant_id, idempotency_key) DO UPDATE SET
	resource_id = EXCLUDED.resource_id,
	status_code = EXCLUDED.status_code,
	response_body = EXCLUDED.response_body
`

type UpsertIdempotencyEntryParams struct {
	TenantID       string
	IdempotencyKey string
	ResourceID     string
	StatusCode     int32
	ResponseBody   []byte
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) UpsertIdempotencyEntry(ctx context.Context, arg UpsertIdempotencyEntryParams) error {
	_, err := q.db.Exec(ctx, upsertIdempotencyEntry,
		arg.TenantID,
		arg.IdempotencyKey,
		arg.ResourceID,
		arg.StatusCode,
		arg.ResponseBody,
		arg.CreatedAt,
	)
	return err
}
